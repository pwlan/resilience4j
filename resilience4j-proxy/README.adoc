= resilience4j-proxy

Resilience4j Proxy uses https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html[Java Dynamic Proxies]
to apply resilience constructs declaratively using annotations.
Unlike other AOP (Aspect-Oriented Programming) technologies, Java Dynamic Proxies are limited to java interfaces.
Therefore, all Resilience4jProxy annotations can only be declared on interfaces and not directly on the classes.
This makes the library especially interesting for other interface-based technologies,
such as https://github.com/OpenFeign/feign[OpenFeign] and https://square.github.io/retrofit[Retrofit].

== Current Features
* CircuitBreaker
* Retry
* RateLimiter
* Fallback
 
 
== Basic Usage

The `Resilience4jProxy` is the main entrypoint for the framework.

``` java
        public interface MyService {

            @Retry
            String getGreeting();
        }

        public interface MyServiceImpl implements MyService {

            String getGreeting() {
               // Make some call that may fail.
            }
        }

       MyService service = new MyServiceImpl();
       MyService decoratedService = Resilience4jProxy.build().apply(MyService.class, service);
       decoratedService.getGreeting(); // MyServiceImpl.getGreeting() will be retried if an exception is thrown.
```

This example is equivalent to decorating `service.getGreeting();` with a `Retry` construct,
i.e. `Retry.decorateCheckedFunction(retry, (args) -> myServiceImpl.getGreeting());`
It is important to note that only calls to `decoratedService.getGreeting()` can trigger a retry.
Calls to `service.getGreeting()` are unaffected.


== Ordering of Decorators

In the case that multiple `Resilience4jProxy` annotations are applied to a service,
the following execution order is applied.

* First `Retry`
* then `RateLimiter`
* then `CircuitBreaker`
* and when all else fails `Fallback`


== Resilience4jProxy Context

Throughout the Resilience4jProxy annotations, classes can be specified that provide some sort of functionality.
The default behaviour is to simply instantiate these classes using no-arg constructors.
However, pre-instantiated classes can also be passed to the framework that are used instead.
This is illustrated in the following example:

``` java
        public interface MyService {

            @Fallback(fallback = MyService.class)
            String getGreeting();
        }

        public interface MyServiceImpl implements MyService {

            String getGreeting() {
               // Make some call that may fail.
            }
        }

       public interface FallbackServiceImpl implements MyService {

            String getGreeting() {
              return "fallback";
            }
        }

       FallbackServiceImpl fallback = new FallbackServiceImpl();
       Map<Class<?>, Object> context = new HashMap<>();
       context.put(MyService.class, fallback);

       MyService service = new MyServiceImpl();
       MyService decoratedService = Resilience4jProxy.build(context).apply(MyService.class, service); // add conext here

```

In this example, whenever a class is defined in an annotation, the framework will use the context to lookup an instance.
If no instance can be found, then a new instance is created.


Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
