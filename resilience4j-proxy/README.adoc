= resilience4j-proxy

Resilience4j Proxy uses https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html[Java Dynamic Proxies]
to apply resilience constructs declaratively using annotations.
Unlike other AOP (Aspect-Oriented Programming) technologies, Java Dynamic Proxies are limited to java interfaces.
Therefore, all Resilience4jProxy annotations can only be declared on interfaces and not directly on the classes.
This makes the library especially interesting for other interface-based technologies,
such as https://github.com/OpenFeign/feign[OpenFeign] and https://square.github.io/retrofit[Retrofit].


== Current Features
* CircuitBreaker
* Retry
* RateLimiter
* Fallback
 
 
== Basic Usage

The `Resilience4jProxy` is the main entrypoint for the framework.

``` java
        public interface MyService {

            @Retry(name = "getGreetingRetry")
            String getGreeting();
        }

        public interface MyServiceImpl implements MyService {

            String getGreeting() {
               // Make some call that may fail.
            }
        }

       MyService service = new MyServiceImpl();
       MyService decoratedService = Resilience4jProxy.build().apply(MyService.class, service);
       decoratedService.getGreeting(); // MyServiceImpl.getGreeting() will be retried if an exception is thrown.
```

This example is equivalent to decorating `service.getGreeting();` with a `Retry` construct,
i.e. `Retry.decorateCheckedFunction(retry, (args) -> myServiceImpl.getGreeting());`
It is important to note that only calls to `decoratedService.getGreeting()` can trigger a retry.
Calls to `service.getGreeting()` are unaffected.
In the example, the Retry uses the default config. To provide a custom Retry, please read the Chapter
"Configuring Resilience4j".


== Configuring Resilience4j

Resilience4j Proxy uses Resilience4j Registries to lookup configuration.
The following example shows how to provide a `RetryRegistry` that contains a custom configuration
for the "getGreetingRetry" Retry:
``` java
        public interface MyService {

            @Retry(name = "getGreetingRetry")
            String getGreeting();
        }

        RetryRegistry retryRegistry = RetryRegistry.ofDefaults();
        retryRegistry.retry("getGreetingRetry", RetryConfig.custom().maxAttempts(4).build());

        ProxyContext context = ProxyContext.builder().withRetryRegistry(retryRegistry).build();
        Resilience4jProxy resilience4jProxy = Resilience4jProxy.build(context);
```


== Defining Fallbacks

`@Fallback` annotations can be defined at the interface level and/or on individual methods.
(`@Fallback` annotations defined on methods overwrite fallbacks defined on the interface level.)

``` java
        public interface MyService {

            @Fallback(fallback = FallbackService.class)
            String getGreeting();
        }

       public interface FallbackService {

            String getGreeting() {
              return "fallback";
            }
        }

       FallbackService fallback = new FallbackService();
       ProxyContext context = ProxyContext.builder().withFallback(FallbackService.class, fallback).build();
       Resilience4jProxy resilience4jProxy = Resilience4jProxy.build(context);
```

Fallbacks are specified with the `ProxyContext#withFallback` method together with a key.
This key is used to match the provided fallbacks with the corresponding `@Fallback` annotations.
If a match cannot be found, the framework will try to instantiate the class declared in the `@Fallback`
annotation directly using a no-arg constructor.

As illustrated in the example, fallbacks are not required to implement
the interface for which they are providing a fallback (however, this is recommended).
It is sufficient the fallback provides methods with matching signatures.
This is mainly useful when fallbacks are only required for a subset of methods.

=== FallbackHandler

The `FallbackHandler` is an interface that fallbacks may implement to obtain more control and flexibility.

``` java

  public interface MyService {

            @Fallback(fallback = FallbackService.class)
            String getGreeting();

            @Fallback(fallback = FallbackService.class)
            String anotherGreeting(String parameter);
  }

   class FallbackService implements FallbackHandler {

      Object handle(CheckedFunction1<Object[], ?> invocationCall,
                  Method method,
                  Object[] args,
                  @Nullable Object result,
                  @Nullable Exception error) throws Exception {
        if(error != null) {
          return "fallback";
        }
        return result;
      }
}
```

By implementing the `FallbackHandler`, the `FallbackService` can be used as a fallback for
multiple methods without having to provide matching method signatures.
Furthermore, `FallbackService#handle` is called on every invocation of the underlining method whether the method throws
an exception or not. This enables Fallbacks to be applied based on method results and not just exceptions.
Finally, another use case for `FallbackHandler` is to retry the failing method. This can be done by simply invoking the
`invocationCall` function passed to the `FallbackService#handle` method.


== Async Methods

Resilience4jProxy annotations can be applied to methods that are executed asynchronously.
For the framework to identify such methods, the return type must be an instance
of or inherit from `CompletionStage`, for example, `CompletableFuture`.
In this case, the corresponding Resilience4j decorators are used, for example,
`Retry#decorateCompletionStage()`.

=== Fallback for Async Methods

Fallbacks can also be applied to methods that are executed asynchronously.
In this case, fallbacks are called after the `CompletionStage` has completed.
Fallbacks themselves may return a `CompletionStage` or the return value directly. In the later case, the returned value
is wrapped in a `CompletableFuture`.

``` java

  public interface MyService {

            @Fallback(fallback = FallbackService.class)
            CompletionStage<String> getGreeting();
  }

   class FallbackService implements FallbackHandler {

      Object handle(CheckedFunction1<Object[], ?> invocationCall,
                  Method method,
                  Object[] args,
                  @Nullable Object result,
                  @Nullable Exception error) throws Exception {
        if(error != null) {
          return "fallback"; // will be automatically wrapped in a CompletableFuture
          // return CompletableFuture.complete(result) would also work
        }
        return result;
      }
}
```


== Ordering of Decorators

In the case that multiple `Resilience4jProxy` annotations are applied to a service,
the following execution order is applied.

* First `Retry`
* then `RateLimiter`
* then `CircuitBreaker`
* and when all else fails `Fallback`


Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
